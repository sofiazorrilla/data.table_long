{"title":"Uniones entre tablas","markdown":{"yaml":{"title":"Uniones entre tablas"},"headingText":"Función `merge`","containsRefs":false,"markdown":"\n\n```{r}\n#| echo: false\nlibrary(data.table)\nlibrary(magrittr)\nlibrary(ggplot2)\nlibrary(ggrepel)\n\n```\n\n\nHay dos formas de escribir uniones entre tablas usando `data.table`. La primera es mediante la función `merge()` de r base. Los argumentos básicos de esta función son:\n\n```\nmerge(x, y, by = intersect(names(x), names(y)),\n      by.x = by, by.y = by, all = FALSE, all.x = all, all.y = all,\n      sort = TRUE, suffixes = c(\".x\",\".y\"), no.dups = TRUE,\n      incomparables = NULL, ...)\n\n```\n\n`x`, `y` = son los objetos data.table que se quieren unir\n\n`by`, `by.x`, `by.y` = nombres de las columnas que funcionan como índice para hacer la unión. Cuando ambas tablas tienen el mismo nombre de columna se utiliza by, cuando no, se puede especificar el nombre en x (by.x) y el nombre en y (by.y)\n\n`all`, `all.x`, `all.y` = especifican el tipo de unión. all = T es para hacer full join (mantiene todas las filas de ambas tablas), all.x = T es para hacer left join (mantiene todas las filas de la tabla x), all.y es para hacer right join (mantiene todas las filas de y), all = F es para hacer inner join (solo mantiene las filas que están en ambas tablas)\n\n\n\n```{r}\n#| echo: true\n\nlibrary(data.table)\n\ndt1 = data.table(id = seq(1,10), letter1 = LETTERS[sample(1:10, replace = T)])\n\ndt2 = data.table(id = seq(6,15), letter2 = LETTERS[sample(1:10, replace = T)])\n\ndt1\ndt2\n\n# inner join\nmerge(dt1,dt2,by = \"id\")\n\n# left join\nmerge(dt1,dt2,by = \"id\", all.x = T)\n\n# right join\nmerge(dt1,dt2,by = \"id\", all.y = T)\n\n# full join\nmerge(dt1,dt2,by = \"id\", all = T)\n```\n\n\n## Sintaxis de `data.table`\n\nLa segunda forma de hacer uniones entre tablas es usando la sintaxis de data.table. \n\n```\nDT1[DT2, nomatch = 0]\n```\n\nSi lo traducimos a la sintaxis de la función anterior entonces la tabla que está por fuera es `x`, la tabla que está por dentro es `y` y el argumento `nomatch` te permite indicar qué hacer con las claves para las que no encuentra coincidencia en ambas tablas. Cuando `nomatch = 0` no incluye las claves que no se comparten entre tablas. \n\n```{r}\n\n# inner join\ndt1[dt2, on = \"id\", nomatch=0]\n\n# left join\ndt1[dt2, on = \"id\"]\n\n# right join\ndt2[dt1, on = \"id\"]\n\n```\n\n## Ejercicio\n\nPara el siguiente ejercicio vamos a cargar varias tablas. Representan la información de muchas canciones de Spotify. A diferencia de la tabla que hemos estado utilizando estas canciones son de musica electrónica de la compañía Beatport. Las tablas fueron descargadas de la siguiente [página](https://www.kaggle.com/datasets/mcfurland/10-m-beatport-tracks-spotify-audio-features?select=bp_track.csv)\n\nLas tablas se relacionan de la siguiente manera:\n\n![](img/ER.png)\n\n```{r}\n#| eval: false\n#| echo: false\n\ntracks <- fread(\"data/bd/bp_track.csv\")\n\nsplit_tracks <- split(tracks, ceiling(seq_along(tracks$track_id) / (length(tracks$track_id)/4)))\n\nlapply(seq_along(split_tracks), function(x){\n      fwrite(x = split_tracks[[x]],file = paste0(\"data/bd/tracks/\",\"tracks_\",x,\".csv.gz\"), compress = \"auto\")})\n\n```\n\n\nNota: El objeto de tracks tiene 10M+ de filas, pesa 2.6 GB cuando está cargado en memoria. Si tu computadora tiene poca memoria puedes elegir no juntar todos los archivos de las canciones (por ejemplo `tracks <- do.call(rbind,data_files[5:6])` para solo cargar dos de los 4 archivos)\n\n```{r}\n# Enlistar los archivos de canciones (guardados en la carpeta de tracks)\ntracks <- list.files(\"data/bd/tracks\", full.names = T)\n\n# Enlistar los archivos restantes en la carpeta bd\nfiles <- c(list.files(\"data/bd\", full.names = T, pattern = \".csv*\"), tracks)\n\n# Leer los archivos usando fread\ndata_files <- lapply(files,fread)\nnames(data_files) <- c(list.files(\"data/bd\", pattern = \".csv*\"), list.files(\"data/bd/tracks\"))\n\n# Guardar los datos en objetos diferentes\ngenre <- data_files$bp_genre.csv\nsubgenre <- data_files$bp_subgenre.csv\nartist <- data_files$bp_artist.csv.gz\nartist_track <- data_files$bp_artist_track.csv.gz\ntracks <- do.call(rbind,data_files[5:8])\n\n# Borrar la lista de archivos\nrm(data_files)\n\n```\n\nNos gustaría explorar la distribución de canciones de diferentes géneros a lo largo del tiempo. Para esto primero tenemos que unir las tablas tracks, genre y subgenre. En el diagrama puedes ver las columnas que las unen. \n\n```{r}\n#| fig-width: 12\n#| fig-height: 8\n#| code-fold: true\n#| warning: false\n\n# Union de tablas\ntracks_genre <- merge(tracks,genre[,.(genre_id,genre_name)],by = \"genre_id\", all.x = T) \n\n# Visualiza el número de canciones por genero que se publicaron cada año (release_date) del 2000 al 2024\n\nfreq_tracks <- tracks_genre[,.N,by = .(genre_name, Yr = format(release_date,\"%Y\"))]\n\n# Opcional: \nlabels <- freq_tracks[, .SD[which.max(N)], by = genre_name][order(-N)][1:5]\n\ncolors <- c(\"#1f77b4\", \"#ff7f0e\", \"#2ca02c\", \"#d62728\", \"#9467bd\", \"gray\")\nnames(colors) <- c(labels$genre_name, \"other\")\n\nfreq_tracks[,color := ifelse(genre_name %in% labels$genre_name, genre_name, \"other\")] \n\nfreq_tracks %>% \n      ggplot(aes(x = as.numeric(Yr), y = N, group = genre_name))+\n      geom_line(color = \"gray\", size = 1, alpha = 0.8)+\n      geom_line(data = freq_tracks[genre_name %in% labels$genre_name], aes(color = factor(color, levels = c(labels$genre_name, \"other\"))), size = 2)+\n      geom_text_repel(data = labels, aes(label = genre_name, color = factor(genre_name, levels = c(labels$genre_name, \"other\"))), nudge_y= 500)+\n      scale_color_manual(values = colors)+\n      scale_x_continuous(limits = c(2000,2025))+\n      labs(x = \"Year\", y = \"N songs\", color = \"Subgenre\")+\n      theme_bw()\n```\n\n::: {.callout-note collapse=\"true\"}\n## Ejercicio\n\nGenera una gráfica similar en la que muestres la distribución de los 5 subgéneros con más canciones en el tiempo.\n\n:::\n::: {.callout-note collapse=\"true\"}\n## Respuesta\n\n```{r}\n#| fig-width: 12\n#| fig-height: 8\n#| echo: false\n#| warning: false\n\n# Union de tablas\ntracks_subgenre <- merge(tracks, subgenre[,.(subgenre_id,subgenre_name)], by = \"subgenre_id\")\n\n# Visualiza el número de canciones por genero que se publicaron cada año (release_date) del 2000 al 2024\n\nfreq_tracks <- tracks_subgenre[,.N,by = .(subgenre_name, Yr = format(release_date,\"%Y\"))]\n\n# Opcional: \nlabels <- freq_tracks[, .SD[which.max(N)], by = subgenre_name][order(-N)][1:5]\n\ncolors <- c(\"#1f77b4\", \"#ff7f0e\", \"#2ca02c\", \"#d62728\", \"#9467bd\", \"gray\")\nnames(colors) <- c(labels$subgenre_name, \"other\")\n\nfreq_tracks[,color := ifelse(subgenre_name %in% labels$subgenre_name, subgenre_name, \"other\")] \n\nfreq_tracks %>% \n      ggplot(aes(x = as.numeric(Yr), y = N, group = subgenre_name))+\n      geom_line(color = \"gray\", size = 1, alpha = 0.8)+\n      geom_line(data = freq_tracks[subgenre_name %in% labels$subgenre_name], aes(color = factor(color, levels = c(labels$subgenre_name, \"other\"))), size = 2)+\n      geom_text_repel(data = labels, aes(label = subgenre_name, color = factor(subgenre_name, levels = c(labels$subgenre_name, \"other\"))), nudge_y= 500)+\n      scale_color_manual(values = colors)+\n      scale_x_continuous(limits = c(2000,2025))+\n      labs(x = \"Year\", y = \"N songs\", color = \"Genre\")+\n      theme_bw()\n```\n:::\n\n\n\n\n\n```{r}\n#| eval: false\n#| echo: false\n\nlibrary('spotifyr')\nlibrary(future.apply)\n\n#' Get Spotify Access Token\n#'\n#' This function prompts the user for their Spotify API credentials (`Client ID` and `Client Secret`),\n#' sets these values as environment variables, and retrieves an access token using the `spotifyr` package.\n#' \n#' To get client id and client secret you must set up a developer account in spotify (https://developer.spotify.com), create an app so that you will get a web API\n#'\n#' @return A Spotify access token as a string.\n#'\n#' @examples\n#' \\dontrun{\n#'   # Call the function to get the access token\n#'   access_token <- get_spotify_access_token_custom()\n#'   print(access_token)\n#' }\n#'\n#' @seealso \\code{\\link{get_spotify_access_token}} from the `spotifyr` package.\n#' \n#' @export\nget_spotify_access_token_custom <- function() {\n  spotify_client_id <- readline(prompt = \"Enter your Spotify Client ID: \")\n  spotify_client_secret <- readline(prompt = \"Enter your Spotify Client Secret: \")\n  \n  Sys.setenv(SPOTIFY_CLIENT_ID = spotify_client_id)\n  Sys.setenv(SPOTIFY_CLIENT_SECRET = spotify_client_secret)\n  \n  access_token <- get_spotify_access_token()\n  return(access_token)\n}\ntoken <- get_spotify_access_token_custom()\n\n\n#' Get Artist Genre for a Spotify Song\n#'\n#' This function retrieves the genres associated with the artists of a given song on Spotify, \n#' using the song's Spotify ID. The genres are retrieved for all artists listed on the track.\n#'\n#' @param spotify_id A character string representing the Spotify track ID.\n#'\n#' @return A data table containing the song ID, artist ID(s), and the associated genre(s).\n#'\n#' @examples\n#' \\dontrun{\n#'   # Get genres for a specific track using its Spotify ID\n#'   song_genres <- get_artist_genre(\"3n3Ppam7vgaVa1iaRUc9Lp\")\n#'   print(song_genres)\n#' }\n#'\n#' @seealso \\code{\\link{get_track}} and \\code{\\link{get_artist}} from the `spotifyr` package.\n#'\n#' @import data.table\n#' @export\nget_artist_genre <- function(spotify_id) {\n  track <- get_track(spotify_id)\n  print(track$name)\n  artist_ids <- track$artists$id\n\n  genres <- sapply(artist_ids, function(artist_id) {\n    artist_info <- get_artist(artist_id)\n    return(artist_info$genres)\n  })\n  \n  result <- data.table(song_id = spotify_id, artist_id = artist_ids, genres = as.list(genres))\n  \n  return(result)\n}\n\n# Obtener el vector único de spotify_id\nspotify_ids <- unique(data$spotify_id)\n\n# Dividir el vector en grupos de 100\nsplit_ids <- split(spotify_ids, ceiling(seq_along(spotify_ids) / 100))\n\nartists_genre <- data.table(id = seq(1, length(split_ids)))\n\ngenres_list <-lapply(seq_along(split_ids)[68:length(split_ids)],        \n      function(x) {\n            artists_genre[id == x,gp_info := list(lapply(split_ids[[x]],get_artist_genre))]\n            Sys.sleep(10)\n      })\n\nsave(artists_genre, file = \"artists_genre.RData\")\n\ncorrect_dt <- unlist(lapply(artists_genre[1,]$gp_info[[1]],function(x){dim(x)[2]}))\nindices <- which(correct_dt == 3)\n\n\n\ntest <- lapply(artists_genre$gp_info,function(x){do.call(rbind,x)}) %>% do.call(rbind,.)\n\n```\n\n","srcMarkdownNoYaml":"\n\n```{r}\n#| echo: false\nlibrary(data.table)\nlibrary(magrittr)\nlibrary(ggplot2)\nlibrary(ggrepel)\n\n```\n\n## Función `merge`\n\nHay dos formas de escribir uniones entre tablas usando `data.table`. La primera es mediante la función `merge()` de r base. Los argumentos básicos de esta función son:\n\n```\nmerge(x, y, by = intersect(names(x), names(y)),\n      by.x = by, by.y = by, all = FALSE, all.x = all, all.y = all,\n      sort = TRUE, suffixes = c(\".x\",\".y\"), no.dups = TRUE,\n      incomparables = NULL, ...)\n\n```\n\n`x`, `y` = son los objetos data.table que se quieren unir\n\n`by`, `by.x`, `by.y` = nombres de las columnas que funcionan como índice para hacer la unión. Cuando ambas tablas tienen el mismo nombre de columna se utiliza by, cuando no, se puede especificar el nombre en x (by.x) y el nombre en y (by.y)\n\n`all`, `all.x`, `all.y` = especifican el tipo de unión. all = T es para hacer full join (mantiene todas las filas de ambas tablas), all.x = T es para hacer left join (mantiene todas las filas de la tabla x), all.y es para hacer right join (mantiene todas las filas de y), all = F es para hacer inner join (solo mantiene las filas que están en ambas tablas)\n\n\n\n```{r}\n#| echo: true\n\nlibrary(data.table)\n\ndt1 = data.table(id = seq(1,10), letter1 = LETTERS[sample(1:10, replace = T)])\n\ndt2 = data.table(id = seq(6,15), letter2 = LETTERS[sample(1:10, replace = T)])\n\ndt1\ndt2\n\n# inner join\nmerge(dt1,dt2,by = \"id\")\n\n# left join\nmerge(dt1,dt2,by = \"id\", all.x = T)\n\n# right join\nmerge(dt1,dt2,by = \"id\", all.y = T)\n\n# full join\nmerge(dt1,dt2,by = \"id\", all = T)\n```\n\n\n## Sintaxis de `data.table`\n\nLa segunda forma de hacer uniones entre tablas es usando la sintaxis de data.table. \n\n```\nDT1[DT2, nomatch = 0]\n```\n\nSi lo traducimos a la sintaxis de la función anterior entonces la tabla que está por fuera es `x`, la tabla que está por dentro es `y` y el argumento `nomatch` te permite indicar qué hacer con las claves para las que no encuentra coincidencia en ambas tablas. Cuando `nomatch = 0` no incluye las claves que no se comparten entre tablas. \n\n```{r}\n\n# inner join\ndt1[dt2, on = \"id\", nomatch=0]\n\n# left join\ndt1[dt2, on = \"id\"]\n\n# right join\ndt2[dt1, on = \"id\"]\n\n```\n\n## Ejercicio\n\nPara el siguiente ejercicio vamos a cargar varias tablas. Representan la información de muchas canciones de Spotify. A diferencia de la tabla que hemos estado utilizando estas canciones son de musica electrónica de la compañía Beatport. Las tablas fueron descargadas de la siguiente [página](https://www.kaggle.com/datasets/mcfurland/10-m-beatport-tracks-spotify-audio-features?select=bp_track.csv)\n\nLas tablas se relacionan de la siguiente manera:\n\n![](img/ER.png)\n\n```{r}\n#| eval: false\n#| echo: false\n\ntracks <- fread(\"data/bd/bp_track.csv\")\n\nsplit_tracks <- split(tracks, ceiling(seq_along(tracks$track_id) / (length(tracks$track_id)/4)))\n\nlapply(seq_along(split_tracks), function(x){\n      fwrite(x = split_tracks[[x]],file = paste0(\"data/bd/tracks/\",\"tracks_\",x,\".csv.gz\"), compress = \"auto\")})\n\n```\n\n\nNota: El objeto de tracks tiene 10M+ de filas, pesa 2.6 GB cuando está cargado en memoria. Si tu computadora tiene poca memoria puedes elegir no juntar todos los archivos de las canciones (por ejemplo `tracks <- do.call(rbind,data_files[5:6])` para solo cargar dos de los 4 archivos)\n\n```{r}\n# Enlistar los archivos de canciones (guardados en la carpeta de tracks)\ntracks <- list.files(\"data/bd/tracks\", full.names = T)\n\n# Enlistar los archivos restantes en la carpeta bd\nfiles <- c(list.files(\"data/bd\", full.names = T, pattern = \".csv*\"), tracks)\n\n# Leer los archivos usando fread\ndata_files <- lapply(files,fread)\nnames(data_files) <- c(list.files(\"data/bd\", pattern = \".csv*\"), list.files(\"data/bd/tracks\"))\n\n# Guardar los datos en objetos diferentes\ngenre <- data_files$bp_genre.csv\nsubgenre <- data_files$bp_subgenre.csv\nartist <- data_files$bp_artist.csv.gz\nartist_track <- data_files$bp_artist_track.csv.gz\ntracks <- do.call(rbind,data_files[5:8])\n\n# Borrar la lista de archivos\nrm(data_files)\n\n```\n\nNos gustaría explorar la distribución de canciones de diferentes géneros a lo largo del tiempo. Para esto primero tenemos que unir las tablas tracks, genre y subgenre. En el diagrama puedes ver las columnas que las unen. \n\n```{r}\n#| fig-width: 12\n#| fig-height: 8\n#| code-fold: true\n#| warning: false\n\n# Union de tablas\ntracks_genre <- merge(tracks,genre[,.(genre_id,genre_name)],by = \"genre_id\", all.x = T) \n\n# Visualiza el número de canciones por genero que se publicaron cada año (release_date) del 2000 al 2024\n\nfreq_tracks <- tracks_genre[,.N,by = .(genre_name, Yr = format(release_date,\"%Y\"))]\n\n# Opcional: \nlabels <- freq_tracks[, .SD[which.max(N)], by = genre_name][order(-N)][1:5]\n\ncolors <- c(\"#1f77b4\", \"#ff7f0e\", \"#2ca02c\", \"#d62728\", \"#9467bd\", \"gray\")\nnames(colors) <- c(labels$genre_name, \"other\")\n\nfreq_tracks[,color := ifelse(genre_name %in% labels$genre_name, genre_name, \"other\")] \n\nfreq_tracks %>% \n      ggplot(aes(x = as.numeric(Yr), y = N, group = genre_name))+\n      geom_line(color = \"gray\", size = 1, alpha = 0.8)+\n      geom_line(data = freq_tracks[genre_name %in% labels$genre_name], aes(color = factor(color, levels = c(labels$genre_name, \"other\"))), size = 2)+\n      geom_text_repel(data = labels, aes(label = genre_name, color = factor(genre_name, levels = c(labels$genre_name, \"other\"))), nudge_y= 500)+\n      scale_color_manual(values = colors)+\n      scale_x_continuous(limits = c(2000,2025))+\n      labs(x = \"Year\", y = \"N songs\", color = \"Subgenre\")+\n      theme_bw()\n```\n\n::: {.callout-note collapse=\"true\"}\n## Ejercicio\n\nGenera una gráfica similar en la que muestres la distribución de los 5 subgéneros con más canciones en el tiempo.\n\n:::\n::: {.callout-note collapse=\"true\"}\n## Respuesta\n\n```{r}\n#| fig-width: 12\n#| fig-height: 8\n#| echo: false\n#| warning: false\n\n# Union de tablas\ntracks_subgenre <- merge(tracks, subgenre[,.(subgenre_id,subgenre_name)], by = \"subgenre_id\")\n\n# Visualiza el número de canciones por genero que se publicaron cada año (release_date) del 2000 al 2024\n\nfreq_tracks <- tracks_subgenre[,.N,by = .(subgenre_name, Yr = format(release_date,\"%Y\"))]\n\n# Opcional: \nlabels <- freq_tracks[, .SD[which.max(N)], by = subgenre_name][order(-N)][1:5]\n\ncolors <- c(\"#1f77b4\", \"#ff7f0e\", \"#2ca02c\", \"#d62728\", \"#9467bd\", \"gray\")\nnames(colors) <- c(labels$subgenre_name, \"other\")\n\nfreq_tracks[,color := ifelse(subgenre_name %in% labels$subgenre_name, subgenre_name, \"other\")] \n\nfreq_tracks %>% \n      ggplot(aes(x = as.numeric(Yr), y = N, group = subgenre_name))+\n      geom_line(color = \"gray\", size = 1, alpha = 0.8)+\n      geom_line(data = freq_tracks[subgenre_name %in% labels$subgenre_name], aes(color = factor(color, levels = c(labels$subgenre_name, \"other\"))), size = 2)+\n      geom_text_repel(data = labels, aes(label = subgenre_name, color = factor(subgenre_name, levels = c(labels$subgenre_name, \"other\"))), nudge_y= 500)+\n      scale_color_manual(values = colors)+\n      scale_x_continuous(limits = c(2000,2025))+\n      labs(x = \"Year\", y = \"N songs\", color = \"Genre\")+\n      theme_bw()\n```\n:::\n\n\n\n\n\n```{r}\n#| eval: false\n#| echo: false\n\nlibrary('spotifyr')\nlibrary(future.apply)\n\n#' Get Spotify Access Token\n#'\n#' This function prompts the user for their Spotify API credentials (`Client ID` and `Client Secret`),\n#' sets these values as environment variables, and retrieves an access token using the `spotifyr` package.\n#' \n#' To get client id and client secret you must set up a developer account in spotify (https://developer.spotify.com), create an app so that you will get a web API\n#'\n#' @return A Spotify access token as a string.\n#'\n#' @examples\n#' \\dontrun{\n#'   # Call the function to get the access token\n#'   access_token <- get_spotify_access_token_custom()\n#'   print(access_token)\n#' }\n#'\n#' @seealso \\code{\\link{get_spotify_access_token}} from the `spotifyr` package.\n#' \n#' @export\nget_spotify_access_token_custom <- function() {\n  spotify_client_id <- readline(prompt = \"Enter your Spotify Client ID: \")\n  spotify_client_secret <- readline(prompt = \"Enter your Spotify Client Secret: \")\n  \n  Sys.setenv(SPOTIFY_CLIENT_ID = spotify_client_id)\n  Sys.setenv(SPOTIFY_CLIENT_SECRET = spotify_client_secret)\n  \n  access_token <- get_spotify_access_token()\n  return(access_token)\n}\ntoken <- get_spotify_access_token_custom()\n\n\n#' Get Artist Genre for a Spotify Song\n#'\n#' This function retrieves the genres associated with the artists of a given song on Spotify, \n#' using the song's Spotify ID. The genres are retrieved for all artists listed on the track.\n#'\n#' @param spotify_id A character string representing the Spotify track ID.\n#'\n#' @return A data table containing the song ID, artist ID(s), and the associated genre(s).\n#'\n#' @examples\n#' \\dontrun{\n#'   # Get genres for a specific track using its Spotify ID\n#'   song_genres <- get_artist_genre(\"3n3Ppam7vgaVa1iaRUc9Lp\")\n#'   print(song_genres)\n#' }\n#'\n#' @seealso \\code{\\link{get_track}} and \\code{\\link{get_artist}} from the `spotifyr` package.\n#'\n#' @import data.table\n#' @export\nget_artist_genre <- function(spotify_id) {\n  track <- get_track(spotify_id)\n  print(track$name)\n  artist_ids <- track$artists$id\n\n  genres <- sapply(artist_ids, function(artist_id) {\n    artist_info <- get_artist(artist_id)\n    return(artist_info$genres)\n  })\n  \n  result <- data.table(song_id = spotify_id, artist_id = artist_ids, genres = as.list(genres))\n  \n  return(result)\n}\n\n# Obtener el vector único de spotify_id\nspotify_ids <- unique(data$spotify_id)\n\n# Dividir el vector en grupos de 100\nsplit_ids <- split(spotify_ids, ceiling(seq_along(spotify_ids) / 100))\n\nartists_genre <- data.table(id = seq(1, length(split_ids)))\n\ngenres_list <-lapply(seq_along(split_ids)[68:length(split_ids)],        \n      function(x) {\n            artists_genre[id == x,gp_info := list(lapply(split_ids[[x]],get_artist_genre))]\n            Sys.sleep(10)\n      })\n\nsave(artists_genre, file = \"artists_genre.RData\")\n\ncorrect_dt <- unlist(lapply(artists_genre[1,]$gp_info[[1]],function(x){dim(x)[2]}))\nindices <- which(correct_dt == 3)\n\n\n\ntest <- lapply(artists_genre$gp_info,function(x){do.call(rbind,x)}) %>% do.call(rbind,.)\n\n```\n\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"knitr"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true,"format-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["styles.css"],"toc":true,"output-file":"tema7.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.3.450","knitr":{"opts_chunk":{"R.options":{"width":120}}},"theme":"flatly","code-wrap":true,"grid":{"body-width":"1000px"},"title":"Uniones entre tablas"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}