{"title":"Uniones entre tablas","markdown":{"yaml":{"title":"Uniones entre tablas"},"headingText":"Función `merge`","containsRefs":false,"markdown":"\n\n\nHay dos formas de escribir uniones entre tablas usando `data.table`. La primera es mediante la función `merge()` de r base. Los argumentos básicos de esta función son:\n\n```\nmerge(x, y, by = intersect(names(x), names(y)),\n      by.x = by, by.y = by, all = FALSE, all.x = all, all.y = all,\n      sort = TRUE, suffixes = c(\".x\",\".y\"), no.dups = TRUE,\n      incomparables = NULL, ...)\n\n```\n\n`x`, `y` = son los objetos data.table que se quieren unir\n\n`by`, `by.x`, `by.y` = nombres de las columnas que funcionan como índice para hacer la unión. Cuando ambas tablas tienen el mismo nombre de columna se utiliza by, cuando no, se puede especificar el nombre en x (by.x) y el nombre en y (by.y)\n\n`all`, `all.x`, `all.y` = especifican el tipo de unión. all = T es para hacer full join (mantiene todas las filas de ambas tablas), all.x = T es para hacer left join (mantiene todas las filas de la tabla x), all.y es para hacer right join (mantiene todas las filas de y), all = F es para hacer inner join (solo mantiene las filas que están en ambas tablas)\n\n\n\n```{r}\n#| echo: true\n\nlibrary(data.table)\n\ndt1 = data.table(id = seq(1,10), letter1 = LETTERS[sample(1:10, replace = T)])\n\ndt2 = data.table(id = seq(6,15), letter2 = LETTERS[sample(1:10, replace = T)])\n\ndt1\ndt2\n\n# inner join\nmerge(dt1,dt2,by = \"id\")\n\n# left join\nmerge(dt1,dt2,by = \"id\", all.x = T)\n\n# right join\nmerge(dt1,dt2,by = \"id\", all.y = T)\n\n# full join\nmerge(dt1,dt2,by = \"id\", all = T)\n```\n\n\n## Sintaxis de `data.table`\n\nLa segunda forma de hacer uniones entre tablas es usando la sintaxis de data.table. \n\n```\nDT1[DT2, nomatch = 0]\n```\n\nSi lo traducimos a la sintaxis de la función anterior entonces la tabla que está por fuera es `x`, la tabla que está por dentro es `y` y el argumento `nomatch` te permite indicar qué hacer con las claves para las que no encuentra coincidencia en ambas tablas. Cuando `nomatch = 0` no incluye las claves que no se comparten entre tablas. \n\n```{r}\n\n# inner join\ndt1[dt2, on = \"id\", nomatch=0]\n\n# left join\ndt1[dt2, on = \"id\"]\n\n# right join\ndt2[dt1, on = \"id\"]\n\n```\n\n\n## Ejercicio\n\nQueremos averiguar cuántos registros y de cuántas especies de algún género de plantas hay de cada categoría de conservación (IUCN) para México. \n\nCon lo aprendido en los temas anteriores podemos generar un subconjunto de la tabla de registros que solo tenga los registros de un género (por ejemplo para el género Quercus).\n\n**Paso 1.** Filtra la tabla de registros de plantas para México para quedarte con la información de algún género que te guste.\n\nAdemás, encontramos que utilizando el paquete `rredlist` podemos buscar el estatus de conservación de la IUCN para algunas especies que nos interesen con la función `rl_search`. \n\nEl siguiente código muestra una forma para obtener el estatus de conservación. Lo que hace es buscar los resultados en la base de datos de la lista roja para cada especie en el subconjunto de registros de encinos de la tabla de registros de plantas para México. \n\n```{r}\n#| eval: false \n\nlibrary(\"rredlist\")\nlibrary(\"magrittr\")\n\ndata = fread(\"data/data_quercus.csv\")\n\ntoken = \"9bb4facb6d23f48efbf424bb05c0c1ef1cf6f468393bc745d42179ac4aca5fee\"\n\nsp_list = unique(data$species)\nsp_list = sp_list[which(sp_list != \"\")] # quitar elementos vacios\n\nred_list = list()\n\nfor (i in sp_list) {\n        red_list[[i]] <- rl_search(i, key = token)$result\n}\n\n# seleccionar columnas útiles\niucn_data = do.call(rbind,red_list) %>% select(scientific_name, category, population_trend)\n\nwrite.csv(iucn_data, \"data/iucn_data.csv\", row.names = F)\n\n```\n\n**Paso 2:** Utiliza el código anterior para generar la tabla de estados de conservación para las especies del género que elegiste.\n\n**Paso 3:** Une la tabla de los registros del genero que escogiste con la de estados de conservación\n\n**Paso 4:** Haz un resumen del número de registros y el número de especies que hay para cada estado de conservación. Por ejemplo, para los encinos los resultados son los siguientes:\n\n```{r}\n#| echo: false\n\ndata = fread(\"data/data_quercus.csv\")\n\ndataIUCN = fread(\"data/iucn_data.csv\")\nsetnames(dataIUCN, \"scientific_name\", \"species\") # renombrar la columna de scientific_name a species porque es la clave que ambas tablas tienen en comun\n\n# Hacer un left join para añadir la información de la iucn a la tabla de datos\njoin = data[dataIUCN, on = \"species\"]\n\n# Hacer el resumen, primero contando los registros agrupando por especie y por categoría. Después, utilizando una cadena y solo agrupamos por categoría, la suma de las filas dentro de un grupo sería el número de registros que pertenecen a la categoría y el número de filas de cada grupo corresponde al número de especies en la categoría.\n\njoin[,.N,by=.(species,category)][,.(numero_registros = sum(N),numero_sp = .N),by = category] |> knitr::kable()\n\n```\n\n::: {.callout-note collapse=\"true\"}\n## Respuesta\n\n```{.r}\n#| echo: false\n\ndata = fread(\"data/data_quercus.csv\")\n\ndataIUCN = fread(\"data/iucn_data.csv\")\nsetnames(dataIUCN, \"scientific_name\", \"species\") # renombrar la columna de scientific_name a species porque es la clave que ambas tablas tienen en comun\n\n# Hacer un left join para añadir la información de la iucn a la tabla de datos\njoin = data[dataIUCN, on = \"species\"]\n\n# Hacer el resumen, primero contando los registros agrupando por especie y por categoría. Después, utilizando una cadena y solo agrupamos por categoría, la suma de las filas dentro de un grupo sería el número de registros que pertenecen a la categoría y el número de filas de cada grupo corresponde al número de especies en la categoría.\n\njoin[,.N,by=.(species,category)][,.(numero_registros = sum(N),numero_sp = .N),by = category] \n\n```\n:::","srcMarkdownNoYaml":"\n\n## Función `merge`\n\nHay dos formas de escribir uniones entre tablas usando `data.table`. La primera es mediante la función `merge()` de r base. Los argumentos básicos de esta función son:\n\n```\nmerge(x, y, by = intersect(names(x), names(y)),\n      by.x = by, by.y = by, all = FALSE, all.x = all, all.y = all,\n      sort = TRUE, suffixes = c(\".x\",\".y\"), no.dups = TRUE,\n      incomparables = NULL, ...)\n\n```\n\n`x`, `y` = son los objetos data.table que se quieren unir\n\n`by`, `by.x`, `by.y` = nombres de las columnas que funcionan como índice para hacer la unión. Cuando ambas tablas tienen el mismo nombre de columna se utiliza by, cuando no, se puede especificar el nombre en x (by.x) y el nombre en y (by.y)\n\n`all`, `all.x`, `all.y` = especifican el tipo de unión. all = T es para hacer full join (mantiene todas las filas de ambas tablas), all.x = T es para hacer left join (mantiene todas las filas de la tabla x), all.y es para hacer right join (mantiene todas las filas de y), all = F es para hacer inner join (solo mantiene las filas que están en ambas tablas)\n\n\n\n```{r}\n#| echo: true\n\nlibrary(data.table)\n\ndt1 = data.table(id = seq(1,10), letter1 = LETTERS[sample(1:10, replace = T)])\n\ndt2 = data.table(id = seq(6,15), letter2 = LETTERS[sample(1:10, replace = T)])\n\ndt1\ndt2\n\n# inner join\nmerge(dt1,dt2,by = \"id\")\n\n# left join\nmerge(dt1,dt2,by = \"id\", all.x = T)\n\n# right join\nmerge(dt1,dt2,by = \"id\", all.y = T)\n\n# full join\nmerge(dt1,dt2,by = \"id\", all = T)\n```\n\n\n## Sintaxis de `data.table`\n\nLa segunda forma de hacer uniones entre tablas es usando la sintaxis de data.table. \n\n```\nDT1[DT2, nomatch = 0]\n```\n\nSi lo traducimos a la sintaxis de la función anterior entonces la tabla que está por fuera es `x`, la tabla que está por dentro es `y` y el argumento `nomatch` te permite indicar qué hacer con las claves para las que no encuentra coincidencia en ambas tablas. Cuando `nomatch = 0` no incluye las claves que no se comparten entre tablas. \n\n```{r}\n\n# inner join\ndt1[dt2, on = \"id\", nomatch=0]\n\n# left join\ndt1[dt2, on = \"id\"]\n\n# right join\ndt2[dt1, on = \"id\"]\n\n```\n\n\n## Ejercicio\n\nQueremos averiguar cuántos registros y de cuántas especies de algún género de plantas hay de cada categoría de conservación (IUCN) para México. \n\nCon lo aprendido en los temas anteriores podemos generar un subconjunto de la tabla de registros que solo tenga los registros de un género (por ejemplo para el género Quercus).\n\n**Paso 1.** Filtra la tabla de registros de plantas para México para quedarte con la información de algún género que te guste.\n\nAdemás, encontramos que utilizando el paquete `rredlist` podemos buscar el estatus de conservación de la IUCN para algunas especies que nos interesen con la función `rl_search`. \n\nEl siguiente código muestra una forma para obtener el estatus de conservación. Lo que hace es buscar los resultados en la base de datos de la lista roja para cada especie en el subconjunto de registros de encinos de la tabla de registros de plantas para México. \n\n```{r}\n#| eval: false \n\nlibrary(\"rredlist\")\nlibrary(\"magrittr\")\n\ndata = fread(\"data/data_quercus.csv\")\n\ntoken = \"9bb4facb6d23f48efbf424bb05c0c1ef1cf6f468393bc745d42179ac4aca5fee\"\n\nsp_list = unique(data$species)\nsp_list = sp_list[which(sp_list != \"\")] # quitar elementos vacios\n\nred_list = list()\n\nfor (i in sp_list) {\n        red_list[[i]] <- rl_search(i, key = token)$result\n}\n\n# seleccionar columnas útiles\niucn_data = do.call(rbind,red_list) %>% select(scientific_name, category, population_trend)\n\nwrite.csv(iucn_data, \"data/iucn_data.csv\", row.names = F)\n\n```\n\n**Paso 2:** Utiliza el código anterior para generar la tabla de estados de conservación para las especies del género que elegiste.\n\n**Paso 3:** Une la tabla de los registros del genero que escogiste con la de estados de conservación\n\n**Paso 4:** Haz un resumen del número de registros y el número de especies que hay para cada estado de conservación. Por ejemplo, para los encinos los resultados son los siguientes:\n\n```{r}\n#| echo: false\n\ndata = fread(\"data/data_quercus.csv\")\n\ndataIUCN = fread(\"data/iucn_data.csv\")\nsetnames(dataIUCN, \"scientific_name\", \"species\") # renombrar la columna de scientific_name a species porque es la clave que ambas tablas tienen en comun\n\n# Hacer un left join para añadir la información de la iucn a la tabla de datos\njoin = data[dataIUCN, on = \"species\"]\n\n# Hacer el resumen, primero contando los registros agrupando por especie y por categoría. Después, utilizando una cadena y solo agrupamos por categoría, la suma de las filas dentro de un grupo sería el número de registros que pertenecen a la categoría y el número de filas de cada grupo corresponde al número de especies en la categoría.\n\njoin[,.N,by=.(species,category)][,.(numero_registros = sum(N),numero_sp = .N),by = category] |> knitr::kable()\n\n```\n\n::: {.callout-note collapse=\"true\"}\n## Respuesta\n\n```{.r}\n#| echo: false\n\ndata = fread(\"data/data_quercus.csv\")\n\ndataIUCN = fread(\"data/iucn_data.csv\")\nsetnames(dataIUCN, \"scientific_name\", \"species\") # renombrar la columna de scientific_name a species porque es la clave que ambas tablas tienen en comun\n\n# Hacer un left join para añadir la información de la iucn a la tabla de datos\njoin = data[dataIUCN, on = \"species\"]\n\n# Hacer el resumen, primero contando los registros agrupando por especie y por categoría. Después, utilizando una cadena y solo agrupamos por categoría, la suma de las filas dentro de un grupo sería el número de registros que pertenecen a la categoría y el número de filas de cada grupo corresponde al número de especies en la categoría.\n\njoin[,.N,by=.(species,category)][,.(numero_registros = sum(N),numero_sp = .N),by = category] \n\n```\n:::"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"knitr"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true,"format-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["styles.css"],"toc":true,"output-file":"tema7.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.3.450","knitr":{"opts_chunk":{"R.options":{"width":120}}},"theme":"flatly","code-wrap":true,"grid":{"body-width":"1000px"},"title":"Uniones entre tablas"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}