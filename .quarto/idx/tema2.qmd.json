{"title":"Importar y exportar datos","markdown":{"yaml":{"title":"Importar y exportar datos"},"headingText":"Crear un objeto data.table","containsRefs":false,"markdown":"\n\n\nUn objeto data.table se puede definir, por ejemplo:\n\n```{r}\nlibrary(data.table)\n\nDT = data.table(\n  ID = c(\"b\",\"b\",\"b\",\"a\",\"a\",\"c\"),\n  a = 1:6,\n  b = 7:12,\n  c = 13:18\n)\n\nDT\n```\n\n<br>\n\n::: {.callout-note collapse=\"true\"}\n## Reto\n\nImaginemos que queremos crear una simulación de una base de datos de secuencias aleatorias. La tabla que queremos al final va a tener dos columnas, la primera es un número identificador de cada secuencia y la segunda la secuencia aleatoria de tamaño 300. Por ejemplo, la siguiente tabla muestra las primeras 10 filas del resultado esperado. \n\n```{r}\n#| echo: false \n#| message: false\n\nlibrary(data.table)\n\nsecuencias <- data.table(\n                id = seq(1,10000), \n                sequencia = sapply(seq(1, 10000), function(x) paste(sample(c(\"A\", \"T\", \"C\", \"G\"), 100, replace = TRUE), collapse = \"\")))\n\nhead(secuencias) |> knitr::kable()\n\n```\n\n**Ejercicio:** Genera un objeto data.table en el que la primera columna sea un id de secuencia y la segunda sea una secuencia (aleatoria) de tamaño 300 caracteres\n\n:::\n\n::: {.callout-note collapse=\"true\"}\n## Respuesta\n\n```{r}\n#| code-fold: true\nsecuencias <- data.table(\n                id = seq(1,10000), \n                sequencia = sapply(seq(1, 10000), function(x) paste(sample(c(\"A\", \"T\", \"C\", \"G\"), 100, replace = TRUE), collapse = \"\")))\n\nhead(secuencias)\n```\n:::\n\n\n<br>\n\n## Importar y exportar datos de archivos\n\nLas funciones para importar (`fread`) y exportar (`fwrite`) tienen las siguientes opciones principales:\n\n- `x`: el objeto que queremos exportar.\n\n- `file`: ruta para escribir/leer el archivo.\n\n- `sep`: el delimitador entre columnas.\n\nNota: La función tiene muchos argumentos que pueden ayudarte a personalizar el proceso de cargar datos en R. \n\n```{.r}\nfread(input, file, text, cmd, sep=\"auto\", sep2=\"auto\", dec=\".\", quote=\"\\\"\",\n     nrows=Inf, header=\"auto\",\n     na.strings=getOption(\"datatable.na.strings\",\"NA\"),  # due to change to \"\"; see NEWS\n     stringsAsFactors=FALSE, verbose=getOption(\"datatable.verbose\", FALSE),\n     skip=\"__auto__\", select=NULL, drop=NULL, colClasses=NULL,\n     integer64=getOption(\"datatable.integer64\", \"integer64\"),\n     col.names,\n     check.names=FALSE, encoding=\"unknown\",\n     strip.white=TRUE, fill=FALSE, blank.lines.skip=FALSE,\n     key=NULL, index=NULL,\n     showProgress=getOption(\"datatable.showProgress\", interactive()),\n     data.table=getOption(\"datatable.fread.datatable\", TRUE),\n     nThread=getDTthreads(verbose),\n     logical01=getOption(\"datatable.logical01\", FALSE),  # due to change to TRUE; see NEWS\n     keepLeadingZeros = getOption(\"datatable.keepLeadingZeros\", FALSE),\n     yaml=FALSE, autostart=NA, tmpdir=tempdir(), tz=\"UTC\"\n     )\n\n```\n\n### Conjunto de datos\n\nMuchos de los ejemplos de este curso los haremos utilizando la tabla de las 50 mejores canciones para 73 paises de acuerdo a Spotify. La tabla la pueden descargar en [kaggle](https://www.kaggle.com/datasets/asaniczka/top-spotify-songs-in-73-countries-daily-updated/data) y se actualiza todos los días. La tabla que yo utilicé para este curso fue descargada el 8 de septiembre 2024. La tabla:\n- Tiene 25 columnas y 1,179,453 registros de canciones\n- Tiene registros desde el 2023-10-18 al 2024-09-08\n- Pesa 279 MB. \n\n**Nota:** `fread()` también permite leer archivos comprimidos `.gz`\n\n```{.r}\nlibrary(data.table)\n\ndata = fread(\"data/universal_top_spotify_songs.csv\", quote=\"\")\n\nhead(data) |> knitr::kable()\n```\n\n```{r}\n#| echo: false\n#| warning: false\n\nlibrary(data.table)\n\nfread(\"data/universal_top_spotify_songs.csv\") |> head() |> knitr::kable()\n\n```\n\n<br>\n\n::: {.callout-note collapse=\"true\"}\n## Reto\n\n\nUtiliza el código anterior para cargar la tabla de canciones en tu computadora. \n\nNota: Si quieres experimentar con tablas más grandes en la página de Kaggle hay muchas opciones. Por ejemplo: [Spotify Charts](https://www.kaggle.com/datasets/dhruvildave/spotify-charts) que contiene las publicaciones de Top 200 y Top 50 globales desde 1 de enero 2017 (pesa 3.5 GB) y tiene 9 columnas. \n\n:::\n\n## Exportar\n\ndata.table también tiene una función optimizada para escribir los datos con los que estamos trabajando en forma de archivo. Los argumentos básicos son:\n\n- `x` = objeto que se quiere exportar como archivo\n- `file` = nombre del archivo\n- `sep` = caracter que se quiere utilizar como delimitador de campo\n- `compress` = debido a que podríamos estar trabajando con tablas de datos muy grandes podemos escribir los archivos comprimidos. Se puede especificar \"gzip\" o \"auto\" y utilizar la extension `.gz` en el nombre del archivo para escribir un archivo comprimido, la opción \"none\" nos permite escribir archivos sin comprimir. \n\n**Ejemplo**: podemos escribir la tabla DT que creamos al principio de la sección:\n\n```{.r}\nfwrite(DT, \"data/testDT.csv\", sep = \",\")\n```\n\n<br>\n\n::: {.callout-note collapse=\"true\"}\n## Ejercicio\n\nExporta la tabla de canciones como un archivo comprimido.\n\n:::\n\n::: {.callout-note collapse=\"true\"}\n## Respuesta\n\n```{.r}\nfwrite(data, \"data/universal_top_spotify_songs.csv.gz\", sep = \",\", compress = \"auto\")\n```\n\n:::\n\n## Velocidad dplyr vs data.table\n\nA continuación se muestra la comparación de un ejemplo de lectura de una tabla de 3062756 filas y 50 columnas utilizando la función de R base `read.csv` y `fread`. \n\n```{.r}\n\nlibrary(rbenchmark)\n\ntest = benchmark(\"r base\" = {\n            read.csv(\"big_data/plantae_mexico_conCoords_specimen.csv\")\n          },\n          \"data.table\" = {\n            fread(\"big_data/plantae_mexico_conCoords_specimen.csv\")\n          },\n          replications = 10,\n          columns = c(\"test\", \"replications\", \"elapsed\",\n                      \"relative\", \"user.self\", \"sys.self\"))\n\n```\n\n```{r}\n#| echo: false\n#| warning: false\n#| eval: true\n\nread.csv(\"data/benchmark_results.csv\") |> knitr::kable()\n```\n\n::: {.callout-note collapse=\"true\"}\n## Reto\n\nSi quieres, puedes revisar el tiempo que te toma cargar la tabla de canciones de spotify utilizando read.csv y fread. Utiliza el comando de benchmark de la paquetería rbenchmark para contar el tiempo. \n\n:::\n\n<br>\n\n## data.frame - data.table\n\nEl objeto de data.table es un objeto basado en un data.frame, por lo tanto es compatible con las funciones de R base que trabajan con data.frame. \n\n```{.r}\nstr(data)\n```\n```\nClasses ‘data.table’ and 'data.frame':  1179453 obs. of  25 variables:\n $ spotify_id        : chr  \"2plbrEY59IikOBgBGLjaoe\" \"6dOtVTDdiauQNBQEDOtlAB\" \"5G2f63n7IPVPPjfNIGih7Q\" \"2HRqTpkrJO5ggZyyK6NPWz\" ...\n $ name              : chr  \"Die With A Smile\" \"BIRDS OF A FEATHER\" \"Taste\" \"Espresso\" ...\n $ artists           : chr  \"Lady Gaga, Bruno Mars\" \"Billie Eilish\" \"Sabrina Carpenter\" \"Sabrina Carpenter\" ...\n $ daily_rank        : int  1 2 3 4 5 6 7 8 9 10 ...\n $ daily_movement    : int  0 0 0 46 0 2 43 1 -2 1 ...\n $ weekly_movement   : int  0 0 0 46 0 1 43 0 41 -1 ...\n $ country           : chr  \"\" \"\" \"\" \"\" ...\n $ snapshot_date     : IDate, format: \"2024-09-08\" \"2024-09-08\" ...\n $ popularity        : int  97 100 94 83 94 96 84 97 77 91 ...\n $ is_explicit       : logi  FALSE FALSE FALSE TRUE FALSE FALSE ...\n $ duration_ms       : int  251667 210373 157279 175459 170887 195824 186365 218423 190427 180304 ...\n $ album_name        : chr  \"Die With A Smile\" \"HIT ME HARD AND SOFT\" \"Short n' Sweet\" \"Short n' Sweet\" ...\n $ album_release_date: IDate, format: \"2024-08-16\" \"2024-05-17\" ...\n $ danceability      : num  0.521 0.747 0.674 0.699 0.66 0.924 0.675 0.7 0.466 0.472 ...\n $ energy            : num  0.592 0.507 0.907 0.776 0.756 0.668 0.586 0.582 0.872 0.471 ...\n $ key               : int  6 2 3 0 0 11 9 11 7 10 ...\n $ loudness          : num  -7.78 -10.17 -4.09 -5.28 -3.74 ...\n $ mode              : int  0 1 1 1 0 1 1 0 1 1 ...\n $ speechiness       : num  0.0304 0.0358 0.064 0.0293 0.032 0.0469 0.0531 0.0356 0.0336 0.0603 ...\n $ acousticness      : num  0.308 0.2 0.101 0.131 0.00289 0.446 0.257 0.0502 0.0156 0.151 ...\n $ instrumentalness  : num  0.00 6.08e-02 0.00 5.36e-06 0.00 5.94e-04 0.00 0.00 0.00 0.00 ...\n $ liveness          : num  0.122 0.117 0.297 0.205 0.193 0.0678 0.104 0.0881 0.121 0.14 ...\n $ valence           : num  0.535 0.438 0.721 0.708 0.838 0.787 0.621 0.785 0.806 0.219 ...\n $ tempo             : num  158 105 113 104 116 ...\n $ time_signature    : int  3 4 4 4 4 4 4 4 4 3 ...\n - attr(*, \".internal.selfref\")=<externalptr> \n\n```\n\nSin embargo, los objetos se pueden cambiar de clase utilizando `as.data.frame` y `setDF` para convertir a data frame o `as.data.table` y `setDT` para convertir a data.table. Por ejemplo: \n\n```{r}\nlibrary(magrittr)\n\n# Recuerda que DT es el objeto data.table que definimos al principio de la lección\n\nas.data.frame(DT) %>% class()\n\nas.data.frame(DT) %>% as.data.table() %>% class()\n\nas.data.frame(DT) %>% setDT(DT) %>% class()\n```\n\nLa diferencia entre las funciones `set` y las funciones `as.` es que la primera modifica directamente la tabla de referencia guardada en la memoria (no genera una copia) mientras que la segunda genera una nueva copia del objeto. \n\n","srcMarkdownNoYaml":"\n\n## Crear un objeto data.table\n\nUn objeto data.table se puede definir, por ejemplo:\n\n```{r}\nlibrary(data.table)\n\nDT = data.table(\n  ID = c(\"b\",\"b\",\"b\",\"a\",\"a\",\"c\"),\n  a = 1:6,\n  b = 7:12,\n  c = 13:18\n)\n\nDT\n```\n\n<br>\n\n::: {.callout-note collapse=\"true\"}\n## Reto\n\nImaginemos que queremos crear una simulación de una base de datos de secuencias aleatorias. La tabla que queremos al final va a tener dos columnas, la primera es un número identificador de cada secuencia y la segunda la secuencia aleatoria de tamaño 300. Por ejemplo, la siguiente tabla muestra las primeras 10 filas del resultado esperado. \n\n```{r}\n#| echo: false \n#| message: false\n\nlibrary(data.table)\n\nsecuencias <- data.table(\n                id = seq(1,10000), \n                sequencia = sapply(seq(1, 10000), function(x) paste(sample(c(\"A\", \"T\", \"C\", \"G\"), 100, replace = TRUE), collapse = \"\")))\n\nhead(secuencias) |> knitr::kable()\n\n```\n\n**Ejercicio:** Genera un objeto data.table en el que la primera columna sea un id de secuencia y la segunda sea una secuencia (aleatoria) de tamaño 300 caracteres\n\n:::\n\n::: {.callout-note collapse=\"true\"}\n## Respuesta\n\n```{r}\n#| code-fold: true\nsecuencias <- data.table(\n                id = seq(1,10000), \n                sequencia = sapply(seq(1, 10000), function(x) paste(sample(c(\"A\", \"T\", \"C\", \"G\"), 100, replace = TRUE), collapse = \"\")))\n\nhead(secuencias)\n```\n:::\n\n\n<br>\n\n## Importar y exportar datos de archivos\n\nLas funciones para importar (`fread`) y exportar (`fwrite`) tienen las siguientes opciones principales:\n\n- `x`: el objeto que queremos exportar.\n\n- `file`: ruta para escribir/leer el archivo.\n\n- `sep`: el delimitador entre columnas.\n\nNota: La función tiene muchos argumentos que pueden ayudarte a personalizar el proceso de cargar datos en R. \n\n```{.r}\nfread(input, file, text, cmd, sep=\"auto\", sep2=\"auto\", dec=\".\", quote=\"\\\"\",\n     nrows=Inf, header=\"auto\",\n     na.strings=getOption(\"datatable.na.strings\",\"NA\"),  # due to change to \"\"; see NEWS\n     stringsAsFactors=FALSE, verbose=getOption(\"datatable.verbose\", FALSE),\n     skip=\"__auto__\", select=NULL, drop=NULL, colClasses=NULL,\n     integer64=getOption(\"datatable.integer64\", \"integer64\"),\n     col.names,\n     check.names=FALSE, encoding=\"unknown\",\n     strip.white=TRUE, fill=FALSE, blank.lines.skip=FALSE,\n     key=NULL, index=NULL,\n     showProgress=getOption(\"datatable.showProgress\", interactive()),\n     data.table=getOption(\"datatable.fread.datatable\", TRUE),\n     nThread=getDTthreads(verbose),\n     logical01=getOption(\"datatable.logical01\", FALSE),  # due to change to TRUE; see NEWS\n     keepLeadingZeros = getOption(\"datatable.keepLeadingZeros\", FALSE),\n     yaml=FALSE, autostart=NA, tmpdir=tempdir(), tz=\"UTC\"\n     )\n\n```\n\n### Conjunto de datos\n\nMuchos de los ejemplos de este curso los haremos utilizando la tabla de las 50 mejores canciones para 73 paises de acuerdo a Spotify. La tabla la pueden descargar en [kaggle](https://www.kaggle.com/datasets/asaniczka/top-spotify-songs-in-73-countries-daily-updated/data) y se actualiza todos los días. La tabla que yo utilicé para este curso fue descargada el 8 de septiembre 2024. La tabla:\n- Tiene 25 columnas y 1,179,453 registros de canciones\n- Tiene registros desde el 2023-10-18 al 2024-09-08\n- Pesa 279 MB. \n\n**Nota:** `fread()` también permite leer archivos comprimidos `.gz`\n\n```{.r}\nlibrary(data.table)\n\ndata = fread(\"data/universal_top_spotify_songs.csv\", quote=\"\")\n\nhead(data) |> knitr::kable()\n```\n\n```{r}\n#| echo: false\n#| warning: false\n\nlibrary(data.table)\n\nfread(\"data/universal_top_spotify_songs.csv\") |> head() |> knitr::kable()\n\n```\n\n<br>\n\n::: {.callout-note collapse=\"true\"}\n## Reto\n\n\nUtiliza el código anterior para cargar la tabla de canciones en tu computadora. \n\nNota: Si quieres experimentar con tablas más grandes en la página de Kaggle hay muchas opciones. Por ejemplo: [Spotify Charts](https://www.kaggle.com/datasets/dhruvildave/spotify-charts) que contiene las publicaciones de Top 200 y Top 50 globales desde 1 de enero 2017 (pesa 3.5 GB) y tiene 9 columnas. \n\n:::\n\n## Exportar\n\ndata.table también tiene una función optimizada para escribir los datos con los que estamos trabajando en forma de archivo. Los argumentos básicos son:\n\n- `x` = objeto que se quiere exportar como archivo\n- `file` = nombre del archivo\n- `sep` = caracter que se quiere utilizar como delimitador de campo\n- `compress` = debido a que podríamos estar trabajando con tablas de datos muy grandes podemos escribir los archivos comprimidos. Se puede especificar \"gzip\" o \"auto\" y utilizar la extension `.gz` en el nombre del archivo para escribir un archivo comprimido, la opción \"none\" nos permite escribir archivos sin comprimir. \n\n**Ejemplo**: podemos escribir la tabla DT que creamos al principio de la sección:\n\n```{.r}\nfwrite(DT, \"data/testDT.csv\", sep = \",\")\n```\n\n<br>\n\n::: {.callout-note collapse=\"true\"}\n## Ejercicio\n\nExporta la tabla de canciones como un archivo comprimido.\n\n:::\n\n::: {.callout-note collapse=\"true\"}\n## Respuesta\n\n```{.r}\nfwrite(data, \"data/universal_top_spotify_songs.csv.gz\", sep = \",\", compress = \"auto\")\n```\n\n:::\n\n## Velocidad dplyr vs data.table\n\nA continuación se muestra la comparación de un ejemplo de lectura de una tabla de 3062756 filas y 50 columnas utilizando la función de R base `read.csv` y `fread`. \n\n```{.r}\n\nlibrary(rbenchmark)\n\ntest = benchmark(\"r base\" = {\n            read.csv(\"big_data/plantae_mexico_conCoords_specimen.csv\")\n          },\n          \"data.table\" = {\n            fread(\"big_data/plantae_mexico_conCoords_specimen.csv\")\n          },\n          replications = 10,\n          columns = c(\"test\", \"replications\", \"elapsed\",\n                      \"relative\", \"user.self\", \"sys.self\"))\n\n```\n\n```{r}\n#| echo: false\n#| warning: false\n#| eval: true\n\nread.csv(\"data/benchmark_results.csv\") |> knitr::kable()\n```\n\n::: {.callout-note collapse=\"true\"}\n## Reto\n\nSi quieres, puedes revisar el tiempo que te toma cargar la tabla de canciones de spotify utilizando read.csv y fread. Utiliza el comando de benchmark de la paquetería rbenchmark para contar el tiempo. \n\n:::\n\n<br>\n\n## data.frame - data.table\n\nEl objeto de data.table es un objeto basado en un data.frame, por lo tanto es compatible con las funciones de R base que trabajan con data.frame. \n\n```{.r}\nstr(data)\n```\n```\nClasses ‘data.table’ and 'data.frame':  1179453 obs. of  25 variables:\n $ spotify_id        : chr  \"2plbrEY59IikOBgBGLjaoe\" \"6dOtVTDdiauQNBQEDOtlAB\" \"5G2f63n7IPVPPjfNIGih7Q\" \"2HRqTpkrJO5ggZyyK6NPWz\" ...\n $ name              : chr  \"Die With A Smile\" \"BIRDS OF A FEATHER\" \"Taste\" \"Espresso\" ...\n $ artists           : chr  \"Lady Gaga, Bruno Mars\" \"Billie Eilish\" \"Sabrina Carpenter\" \"Sabrina Carpenter\" ...\n $ daily_rank        : int  1 2 3 4 5 6 7 8 9 10 ...\n $ daily_movement    : int  0 0 0 46 0 2 43 1 -2 1 ...\n $ weekly_movement   : int  0 0 0 46 0 1 43 0 41 -1 ...\n $ country           : chr  \"\" \"\" \"\" \"\" ...\n $ snapshot_date     : IDate, format: \"2024-09-08\" \"2024-09-08\" ...\n $ popularity        : int  97 100 94 83 94 96 84 97 77 91 ...\n $ is_explicit       : logi  FALSE FALSE FALSE TRUE FALSE FALSE ...\n $ duration_ms       : int  251667 210373 157279 175459 170887 195824 186365 218423 190427 180304 ...\n $ album_name        : chr  \"Die With A Smile\" \"HIT ME HARD AND SOFT\" \"Short n' Sweet\" \"Short n' Sweet\" ...\n $ album_release_date: IDate, format: \"2024-08-16\" \"2024-05-17\" ...\n $ danceability      : num  0.521 0.747 0.674 0.699 0.66 0.924 0.675 0.7 0.466 0.472 ...\n $ energy            : num  0.592 0.507 0.907 0.776 0.756 0.668 0.586 0.582 0.872 0.471 ...\n $ key               : int  6 2 3 0 0 11 9 11 7 10 ...\n $ loudness          : num  -7.78 -10.17 -4.09 -5.28 -3.74 ...\n $ mode              : int  0 1 1 1 0 1 1 0 1 1 ...\n $ speechiness       : num  0.0304 0.0358 0.064 0.0293 0.032 0.0469 0.0531 0.0356 0.0336 0.0603 ...\n $ acousticness      : num  0.308 0.2 0.101 0.131 0.00289 0.446 0.257 0.0502 0.0156 0.151 ...\n $ instrumentalness  : num  0.00 6.08e-02 0.00 5.36e-06 0.00 5.94e-04 0.00 0.00 0.00 0.00 ...\n $ liveness          : num  0.122 0.117 0.297 0.205 0.193 0.0678 0.104 0.0881 0.121 0.14 ...\n $ valence           : num  0.535 0.438 0.721 0.708 0.838 0.787 0.621 0.785 0.806 0.219 ...\n $ tempo             : num  158 105 113 104 116 ...\n $ time_signature    : int  3 4 4 4 4 4 4 4 4 3 ...\n - attr(*, \".internal.selfref\")=<externalptr> \n\n```\n\nSin embargo, los objetos se pueden cambiar de clase utilizando `as.data.frame` y `setDF` para convertir a data frame o `as.data.table` y `setDT` para convertir a data.table. Por ejemplo: \n\n```{r}\nlibrary(magrittr)\n\n# Recuerda que DT es el objeto data.table que definimos al principio de la lección\n\nas.data.frame(DT) %>% class()\n\nas.data.frame(DT) %>% as.data.table() %>% class()\n\nas.data.frame(DT) %>% setDT(DT) %>% class()\n```\n\nLa diferencia entre las funciones `set` y las funciones `as.` es que la primera modifica directamente la tabla de referencia guardada en la memoria (no genera una copia) mientras que la segunda genera una nueva copia del objeto. \n\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"knitr"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true,"format-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["styles.css"],"toc":true,"output-file":"tema2.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.3.450","knitr":{"opts_chunk":{"R.options":{"width":120}}},"theme":"flatly","code-wrap":true,"grid":{"body-width":"1000px"},"title":"Importar y exportar datos"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}