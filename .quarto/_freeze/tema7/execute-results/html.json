{
  "hash": "201051862d73580e71d9abfe65101a96",
  "result": {
    "markdown": "---\ntitle: \"Uniones entre tablas\"\n---\n\n\n## Función `merge`\n\nHay dos formas de escribir uniones entre tablas usando `data.table`. La primera es mediante la función `merge()` de r base. Los argumentos básicos de esta función son:\n\n```\nmerge(x, y, by = intersect(names(x), names(y)),\n      by.x = by, by.y = by, all = FALSE, all.x = all, all.y = all,\n      sort = TRUE, suffixes = c(\".x\",\".y\"), no.dups = TRUE,\n      incomparables = NULL, ...)\n\n```\n\n`x`, `y` = son los objetos data.table que se quieren unir\n\n`by`, `by.x`, `by.y` = nombres de las columnas que funcionan como índice para hacer la unión. Cuando ambas tablas tienen el mismo nombre de columna se utiliza by, cuando no, se puede especificar el nombre en x (by.x) y el nombre en y (by.y)\n\n`all`, `all.x`, `all.y` = especifican el tipo de unión. all = T es para hacer full join (mantiene todas las filas de ambas tablas), all.x = T es para hacer left join (mantiene todas las filas de la tabla x), all.y es para hacer right join (mantiene todas las filas de y), all = F es para hacer inner join (solo mantiene las filas que están en ambas tablas)\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(data.table)\n\ndt1 = data.table(id = seq(1,10), letter1 = LETTERS[sample(1:10, replace = T)])\n\ndt2 = data.table(id = seq(6,15), letter2 = LETTERS[sample(1:10, replace = T)])\n\ndt1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       id letter1\n    <int>  <char>\n 1:     1       C\n 2:     2       H\n 3:     3       J\n 4:     4       J\n 5:     5       I\n 6:     6       E\n 7:     7       B\n 8:     8       H\n 9:     9       A\n10:    10       J\n```\n:::\n\n```{.r .cell-code}\ndt2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       id letter2\n    <int>  <char>\n 1:     6       J\n 2:     7       B\n 3:     8       I\n 4:     9       E\n 5:    10       I\n 6:    11       E\n 7:    12       I\n 8:    13       C\n 9:    14       C\n10:    15       H\n```\n:::\n\n```{.r .cell-code}\n# inner join\nmerge(dt1,dt2,by = \"id\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nKey: <id>\n      id letter1 letter2\n   <int>  <char>  <char>\n1:     6       E       J\n2:     7       B       B\n3:     8       H       I\n4:     9       A       E\n5:    10       J       I\n```\n:::\n\n```{.r .cell-code}\n# left join\nmerge(dt1,dt2,by = \"id\", all.x = T)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nKey: <id>\n       id letter1 letter2\n    <int>  <char>  <char>\n 1:     1       C    <NA>\n 2:     2       H    <NA>\n 3:     3       J    <NA>\n 4:     4       J    <NA>\n 5:     5       I    <NA>\n 6:     6       E       J\n 7:     7       B       B\n 8:     8       H       I\n 9:     9       A       E\n10:    10       J       I\n```\n:::\n\n```{.r .cell-code}\n# right join\nmerge(dt1,dt2,by = \"id\", all.y = T)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nKey: <id>\n       id letter1 letter2\n    <int>  <char>  <char>\n 1:     6       E       J\n 2:     7       B       B\n 3:     8       H       I\n 4:     9       A       E\n 5:    10       J       I\n 6:    11    <NA>       E\n 7:    12    <NA>       I\n 8:    13    <NA>       C\n 9:    14    <NA>       C\n10:    15    <NA>       H\n```\n:::\n\n```{.r .cell-code}\n# full join\nmerge(dt1,dt2,by = \"id\", all = T)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nKey: <id>\n       id letter1 letter2\n    <int>  <char>  <char>\n 1:     1       C    <NA>\n 2:     2       H    <NA>\n 3:     3       J    <NA>\n 4:     4       J    <NA>\n 5:     5       I    <NA>\n 6:     6       E       J\n 7:     7       B       B\n 8:     8       H       I\n 9:     9       A       E\n10:    10       J       I\n11:    11    <NA>       E\n12:    12    <NA>       I\n13:    13    <NA>       C\n14:    14    <NA>       C\n15:    15    <NA>       H\n```\n:::\n:::\n\n\n\n## Sintaxis de `data.table`\n\nLa segunda forma de hacer uniones entre tablas es usando la sintaxis de data.table. \n\n```\nDT1[DT2, nomatch = 0]\n```\n\nSi lo traducimos a la sintaxis de la función anterior entonces la tabla que está por fuera es `x`, la tabla que está por dentro es `y` y el argumento `nomatch` te permite indicar qué hacer con las claves para las que no encuentra coincidencia en ambas tablas. Cuando `nomatch = 0` no incluye las claves que no se comparten entre tablas. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# inner join\ndt1[dt2, on = \"id\", nomatch=0]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      id letter1 letter2\n   <int>  <char>  <char>\n1:     6       E       J\n2:     7       B       B\n3:     8       H       I\n4:     9       A       E\n5:    10       J       I\n```\n:::\n\n```{.r .cell-code}\n# left join\ndt1[dt2, on = \"id\"]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       id letter1 letter2\n    <int>  <char>  <char>\n 1:     6       E       J\n 2:     7       B       B\n 3:     8       H       I\n 4:     9       A       E\n 5:    10       J       I\n 6:    11    <NA>       E\n 7:    12    <NA>       I\n 8:    13    <NA>       C\n 9:    14    <NA>       C\n10:    15    <NA>       H\n```\n:::\n\n```{.r .cell-code}\n# right join\ndt2[dt1, on = \"id\"]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       id letter2 letter1\n    <int>  <char>  <char>\n 1:     1    <NA>       C\n 2:     2    <NA>       H\n 3:     3    <NA>       J\n 4:     4    <NA>       J\n 5:     5    <NA>       I\n 6:     6       J       E\n 7:     7       B       B\n 8:     8       I       H\n 9:     9       E       A\n10:    10       I       J\n```\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}