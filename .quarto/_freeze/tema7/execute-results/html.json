{
  "hash": "a032e6fa12b61b010b49d60f4f5ca975",
  "result": {
    "markdown": "---\ntitle: \"Uniones entre tablas\"\n---\n\n::: {.cell}\n\n:::\n\n\n## Función `merge`\n\nHay dos formas de escribir uniones entre tablas usando `data.table`. La primera es mediante la función `merge()` de r base. Los argumentos básicos de esta función son:\n\n```\nmerge(x, y, by = intersect(names(x), names(y)),\n      by.x = by, by.y = by, all = FALSE, all.x = all, all.y = all,\n      sort = TRUE, suffixes = c(\".x\",\".y\"), no.dups = TRUE,\n      incomparables = NULL, ...)\n\n```\n\n`x`, `y` = son los objetos data.table que se quieren unir\n\n`by`, `by.x`, `by.y` = nombres de las columnas que funcionan como índice para hacer la unión. Cuando ambas tablas tienen el mismo nombre de columna se utiliza by, cuando no, se puede especificar el nombre en x (by.x) y el nombre en y (by.y)\n\n`all`, `all.x`, `all.y` = especifican el tipo de unión. all = T es para hacer full join (mantiene todas las filas de ambas tablas), all.x = T es para hacer left join (mantiene todas las filas de la tabla x), all.y es para hacer right join (mantiene todas las filas de y), all = F es para hacer inner join (solo mantiene las filas que están en ambas tablas)\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(data.table)\n\ndt1 = data.table(id = seq(1,10), letter1 = LETTERS[sample(1:10, replace = T)])\n\ndt2 = data.table(id = seq(6,15), letter2 = LETTERS[sample(1:10, replace = T)])\n\ndt1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       id letter1\n    <int>  <char>\n 1:     1       I\n 2:     2       D\n 3:     3       G\n 4:     4       H\n 5:     5       F\n 6:     6       D\n 7:     7       J\n 8:     8       G\n 9:     9       E\n10:    10       G\n```\n:::\n\n```{.r .cell-code}\ndt2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       id letter2\n    <int>  <char>\n 1:     6       F\n 2:     7       H\n 3:     8       I\n 4:     9       H\n 5:    10       D\n 6:    11       E\n 7:    12       G\n 8:    13       E\n 9:    14       C\n10:    15       H\n```\n:::\n\n```{.r .cell-code}\n# inner join\nmerge(dt1,dt2,by = \"id\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nKey: <id>\n      id letter1 letter2\n   <int>  <char>  <char>\n1:     6       D       F\n2:     7       J       H\n3:     8       G       I\n4:     9       E       H\n5:    10       G       D\n```\n:::\n\n```{.r .cell-code}\n# left join\nmerge(dt1,dt2,by = \"id\", all.x = T)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nKey: <id>\n       id letter1 letter2\n    <int>  <char>  <char>\n 1:     1       I    <NA>\n 2:     2       D    <NA>\n 3:     3       G    <NA>\n 4:     4       H    <NA>\n 5:     5       F    <NA>\n 6:     6       D       F\n 7:     7       J       H\n 8:     8       G       I\n 9:     9       E       H\n10:    10       G       D\n```\n:::\n\n```{.r .cell-code}\n# right join\nmerge(dt1,dt2,by = \"id\", all.y = T)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nKey: <id>\n       id letter1 letter2\n    <int>  <char>  <char>\n 1:     6       D       F\n 2:     7       J       H\n 3:     8       G       I\n 4:     9       E       H\n 5:    10       G       D\n 6:    11    <NA>       E\n 7:    12    <NA>       G\n 8:    13    <NA>       E\n 9:    14    <NA>       C\n10:    15    <NA>       H\n```\n:::\n\n```{.r .cell-code}\n# full join\nmerge(dt1,dt2,by = \"id\", all = T)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nKey: <id>\n       id letter1 letter2\n    <int>  <char>  <char>\n 1:     1       I    <NA>\n 2:     2       D    <NA>\n 3:     3       G    <NA>\n 4:     4       H    <NA>\n 5:     5       F    <NA>\n 6:     6       D       F\n 7:     7       J       H\n 8:     8       G       I\n 9:     9       E       H\n10:    10       G       D\n11:    11    <NA>       E\n12:    12    <NA>       G\n13:    13    <NA>       E\n14:    14    <NA>       C\n15:    15    <NA>       H\n```\n:::\n:::\n\n\n\n## Sintaxis de `data.table`\n\nLa segunda forma de hacer uniones entre tablas es usando la sintaxis de data.table. \n\n```\nDT1[DT2, nomatch = 0]\n```\n\nSi lo traducimos a la sintaxis de la función anterior entonces la tabla que está por fuera es `x`, la tabla que está por dentro es `y` y el argumento `nomatch` te permite indicar qué hacer con las claves para las que no encuentra coincidencia en ambas tablas. Cuando `nomatch = 0` no incluye las claves que no se comparten entre tablas. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# inner join\ndt1[dt2, on = \"id\", nomatch=0]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      id letter1 letter2\n   <int>  <char>  <char>\n1:     6       D       F\n2:     7       J       H\n3:     8       G       I\n4:     9       E       H\n5:    10       G       D\n```\n:::\n\n```{.r .cell-code}\n# left join\ndt1[dt2, on = \"id\"]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       id letter1 letter2\n    <int>  <char>  <char>\n 1:     6       D       F\n 2:     7       J       H\n 3:     8       G       I\n 4:     9       E       H\n 5:    10       G       D\n 6:    11    <NA>       E\n 7:    12    <NA>       G\n 8:    13    <NA>       E\n 9:    14    <NA>       C\n10:    15    <NA>       H\n```\n:::\n\n```{.r .cell-code}\n# right join\ndt2[dt1, on = \"id\"]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       id letter2 letter1\n    <int>  <char>  <char>\n 1:     1    <NA>       I\n 2:     2    <NA>       D\n 3:     3    <NA>       G\n 4:     4    <NA>       H\n 5:     5    <NA>       F\n 6:     6       F       D\n 7:     7       H       J\n 8:     8       I       G\n 9:     9       H       E\n10:    10       D       G\n```\n:::\n:::\n\n\n## Ejercicio\n\nPara el siguiente ejercicio vamos a cargar varias tablas. Representan la información de muchas canciones de Spotify. A diferencia de la tabla que hemos estado utilizando estas canciones son de musica electrónica de la compañía Beatport. Las tablas fueron descargadas de la siguiente [página](https://www.kaggle.com/datasets/mcfurland/10-m-beatport-tracks-spotify-audio-features?select=bp_track.csv)\n\nLas tablas se relacionan de la siguiente manera:\n\n![](img/ER.png)\n\n\n::: {.cell}\n\n:::\n\n\n\nNota: El objeto de tracks tiene 10M+ de filas, pesa 2.6 GB cuando está cargado en memoria. Si tu computadora tiene poca memoria puedes elegir no juntar todos los archivos de las canciones (por ejemplo `tracks <- do.call(rbind,data_files[5:6])` para solo cargar dos de los 4 archivos)\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Enlistar los archivos de canciones (guardados en la carpeta de tracks)\ntracks <- list.files(\"data/bd/tracks\", full.names = T)\n\n# Enlistar los archivos restantes en la carpeta bd\nfiles <- c(list.files(\"data/bd\", full.names = T, pattern = \".csv*\"), tracks)\n\n# Leer los archivos usando fread\ndata_files <- lapply(files,fread)\nnames(data_files) <- c(list.files(\"data/bd\", pattern = \".csv*\"), list.files(\"data/bd/tracks\"))\n\n# Guardar los datos en objetos diferentes\ngenre <- data_files$bp_genre.csv\nsubgenre <- data_files$bp_subgenre.csv\nartist <- data_files$bp_artist.csv.gz\nartist_track <- data_files$bp_artist_track.csv.gz\ntracks <- do.call(rbind,data_files[5:8])\n\n# Borrar la lista de archivos\nrm(data_files)\n```\n:::\n\n\nNos gustaría explorar la distribución de canciones de diferentes géneros a lo largo del tiempo. Para esto primero tenemos que unir las tablas tracks, genre y subgenre. En el diagrama puedes ver las columnas que las unen. \n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\n# Union de tablas\ntracks_genre <- merge(tracks,genre[,.(genre_id,genre_name)],by = \"genre_id\", all.x = T) \n\n# Visualiza el número de canciones por genero que se publicaron cada año (release_date) del 2000 al 2024\n\nfreq_tracks <- tracks_genre[,.N,by = .(genre_name, Yr = format(release_date,\"%Y\"))]\n\n# Opcional: \nlabels <- freq_tracks[, .SD[which.max(N)], by = genre_name][order(-N)][1:5]\n\ncolors <- c(\"#1f77b4\", \"#ff7f0e\", \"#2ca02c\", \"#d62728\", \"#9467bd\", \"gray\")\nnames(colors) <- c(labels$genre_name, \"other\")\n\nfreq_tracks[,color := ifelse(genre_name %in% labels$genre_name, genre_name, \"other\")] \n\nfreq_tracks %>% \n      ggplot(aes(x = as.numeric(Yr), y = N, group = genre_name))+\n      geom_line(color = \"gray\", size = 1, alpha = 0.8)+\n      geom_line(data = freq_tracks[genre_name %in% labels$genre_name], aes(color = factor(color, levels = c(labels$genre_name, \"other\"))), size = 2)+\n      geom_text_repel(data = labels, aes(label = genre_name, color = factor(genre_name, levels = c(labels$genre_name, \"other\"))), nudge_y= 500)+\n      scale_color_manual(values = colors)+\n      scale_x_continuous(limits = c(2000,2025))+\n      labs(x = \"Year\", y = \"N songs\", color = \"Subgenre\")+\n      theme_bw()\n```\n\n::: {.cell-output-display}\n![](tema7_files/figure-html/unnamed-chunk-6-1.png){width=1152}\n:::\n:::\n\n\n::: {.callout-note collapse=\"true\"}\n## Ejercicio\n\nGenera una gráfica similar en la que muestres la distribución de los 5 subgéneros con más canciones en el tiempo.\n\n:::\n::: {.callout-note collapse=\"true\"}\n## Respuesta\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](tema7_files/figure-html/unnamed-chunk-7-1.png){width=1152}\n:::\n:::\n\n:::\n\n\n\n\n\n\n::: {.cell}\n\n:::\n",
    "supporting": [
      "tema7_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}